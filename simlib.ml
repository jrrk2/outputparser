open Printf

let simlib fd =
  fprintf fd "/*\n";
  fprintf fd " *  yosys -- Yosys Open SYnthesis Suite\n";
  fprintf fd " *\n";
  fprintf fd " *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\n";
  fprintf fd " *\n";
  fprintf fd " *  Permission to use, copy, modify, and/or distribute this software for any\n";
  fprintf fd " *  purpose with or without fee is hereby granted, provided that the above\n";
  fprintf fd " *  copyright notice and this permission notice appear in all copies.\n";
  fprintf fd " *\n";
  fprintf fd " *  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n";
  fprintf fd " *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n";
  fprintf fd " *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n";
  fprintf fd " *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n";
  fprintf fd " *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n";
  fprintf fd " *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n";
  fprintf fd " *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n";
  fprintf fd " *\n";
  fprintf fd " *  ---\n";
  fprintf fd " *\n";
  fprintf fd " *  The Simulation Library.\n";
  fprintf fd " *\n";
  fprintf fd " *  This Verilog library contains simple simulation models for the internal\n";
  fprintf fd " *  cells ($not, ...) generated by the frontends and used in most passes.\n";
  fprintf fd " *\n";
  fprintf fd " *  This library can be used to verify the internal netlists as generated\n";
  fprintf fd " *  by the different frontends and passes.\n";
  fprintf fd " *\n";
  fprintf fd " *  Note that memory can only be simulated when all $memrd and $memwr cells\n";
  fprintf fd " *  have been merged to stand-alone $mem cells (this is what the \"memory_collect\"\n";
  fprintf fd " *  pass is doing).\n";
  fprintf fd " *\n";
  fprintf fd " */\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $not (A, Y)\n";
  fprintf fd "//-\n";
  fprintf fd "//- A bit-wise inverter. This corresponds to the Verilog unary prefix '~' operator.\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$not (A, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = ~$signed(A);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = ~A;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $pos (A, Y)\n";
  fprintf fd "//-\n";
  fprintf fd "//- A buffer. This corresponds to the Verilog unary prefix '+' operator.\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$pos (A, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $neg (A, Y)\n";
  fprintf fd "//-\n";
  fprintf fd "//- An arithmetic inverter. This corresponds to the Verilog unary prefix '-' operator.\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$neg (A, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = -$signed(A);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = -A;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $and (A, B, Y)\n";
  fprintf fd "//-\n";
  fprintf fd "//- A bit-wise AND. This corresponds to the Verilog '&' operator.\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$and (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) & $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A & B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $or (A, B, Y)\n";
  fprintf fd "//-\n";
  fprintf fd "//- A bit-wise OR. This corresponds to the Verilog '|' operator.\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$or (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) | $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A | B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $xor (A, B, Y)\n";
  fprintf fd "//-\n";
  fprintf fd "//- A bit-wise XOR. This corresponds to the Verilog '^' operator.\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$xor (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) ^ $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A ^ B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $xnor (A, B, Y)\n";
  fprintf fd "//-\n";
  fprintf fd "//- A bit-wise XNOR. This corresponds to the Verilog '~^' operator.\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$xnor (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) ~^ $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A ~^ B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $reduce_and (A, Y)\n";
  fprintf fd "//-\n";
  fprintf fd "//- An AND reduction. This corresponds to the Verilog unary prefix '&' operator.\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$reduce_and (A, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = &$signed(A);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = &A;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $reduce_or (A, Y)\n";
  fprintf fd "//-\n";
  fprintf fd "//- An OR reduction. This corresponds to the Verilog unary prefix '|' operator.\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$reduce_or (A, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = |$signed(A);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = |A;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $reduce_xor (A, Y)\n";
  fprintf fd "//-\n";
  fprintf fd "//- A XOR reduction. This corresponds to the Verilog unary prefix '^' operator.\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$reduce_xor (A, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = ^$signed(A);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = ^A;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $reduce_xnor (A, Y)\n";
  fprintf fd "//-\n";
  fprintf fd "//- A XNOR reduction. This corresponds to the Verilog unary prefix '~^' operator.\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$reduce_xnor (A, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = ~^$signed(A);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = ~^A;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $reduce_bool (A, Y)\n";
  fprintf fd "//-\n";
  fprintf fd "//- An OR reduction. This cell type is used instead of $reduce_or when a signal is\n";
  fprintf fd "//- implicitly converted to a boolean signal, e.g. for operands of '&&' and '||'.\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$reduce_bool (A, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = !(!$signed(A));\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = !(!A);\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$shl (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) << B;\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A << B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$shr (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) >> B;\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A >> B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$sshl (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) <<< B;\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A <<< B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$sshr (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) >>> B;\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A >>> B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$shift (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED) begin:BLOCK1\n";
  fprintf fd "		if (B_SIGNED) begin:BLOCK2\n";
  fprintf fd "			assign Y = $signed(B) < 0 ? $signed(A) << -B : $signed(A) >> B;\n";
  fprintf fd "		end else begin:BLOCK3\n";
  fprintf fd "			assign Y = $signed(A) >> B;\n";
  fprintf fd "		end\n";
  fprintf fd "	end else begin:BLOCK4\n";
  fprintf fd "		if (B_SIGNED) begin:BLOCK5\n";
  fprintf fd "			assign Y = $signed(B) < 0 ? A << -B : A >> B;\n";
  fprintf fd "		end else begin:BLOCK6\n";
  fprintf fd "			assign Y = A >> B;\n";
  fprintf fd "		end\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$shiftx (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (Y_WIDTH > 0)\n";
  fprintf fd "		if (B_SIGNED) begin:BLOCK1\n";
  fprintf fd "			assign Y = A[$signed(B) +: Y_WIDTH];\n";
  fprintf fd "		end else begin:BLOCK2\n";
  fprintf fd "			assign Y = A[B +: Y_WIDTH];\n";
  fprintf fd "		end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$fa (A, B, C, X, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 1;\n";
  fprintf fd "\n";
  fprintf fd "input [WIDTH-1:0] A, B, C;\n";
  fprintf fd "output [WIDTH-1:0] X, Y;\n";
  fprintf fd "\n";
  fprintf fd "wire [WIDTH-1:0] t1, t2, t3;\n";
  fprintf fd "\n";
  fprintf fd "assign t1 = A ^ B, t2 = A & B, t3 = C & t1;\n";
  fprintf fd "assign Y = t1 ^ C, X = (t2 | t3) ^ (Y ^ Y);\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $lcu (P, G, CI, CO)\n";
  fprintf fd "//-\n";
  fprintf fd "//- Lookahead carry unit\n";
  fprintf fd "//- A building block dedicated to fast computation of carry-bits used in binary\n";
  fprintf fd "//- arithmetic operations. By replacing the ripple carry structure used in full-adder\n";
  fprintf fd "//- blocks, the more significant  bits of the sum can be expected to be computed more\n";
  fprintf fd "//- quickly.\n";
  fprintf fd "//- Typically created during `techmap` of $alu cells (see the \"_90_alu\" rule in\n";
  fprintf fd "//- +/techmap.v).\n";
  fprintf fd "module \\$lcu (P, G, CI, CO);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 1;\n";
  fprintf fd "\n";
  fprintf fd "input [WIDTH-1:0] P;    // Propagate\n";
  fprintf fd "input [WIDTH-1:0] G;    // Generate\n";
  fprintf fd "input CI;               // Carry-in\n";
  fprintf fd "\n";
  fprintf fd "output reg [WIDTH-1:0] CO; // Carry-out\n";
  fprintf fd "\n";
  fprintf fd "integer i;\n";
  fprintf fd "always @* begin\n";
  fprintf fd "	CO = 'bx;\n";
  fprintf fd "	if (^{P, G, CI} !== 1'bx) begin\n";
  fprintf fd "		CO[0] = G[0] || (P[0] && CI);\n";
  fprintf fd "		for (i = 1; i < WIDTH; i = i+1)\n";
  fprintf fd "			CO[i] = G[i] || (P[i] && CO[i-1]);\n";
  fprintf fd "	end\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $alu (A, B, CI, BI, X, Y, CO)\n";
  fprintf fd "//-\n";
  fprintf fd "//- Arithmetic logic unit.\n";
  fprintf fd "//- A building block supporting both binary addition/subtraction operations, and\n";
  fprintf fd "//- indirectly, comparison operations.\n";
  fprintf fd "//- Typically created by the `alumacc` pass, which transforms:\n";
  fprintf fd "//-   $add, $sub, $lt, $le, $ge, $gt, $eq, $eqx, $ne, $nex\n";
  fprintf fd "//- cells into this $alu cell.\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$alu (A, B, CI, BI, X, Y, CO);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 1;\n";
  fprintf fd "parameter B_WIDTH = 1;\n";
  fprintf fd "parameter Y_WIDTH = 1;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;      // Input operand\n";
  fprintf fd "input [B_WIDTH-1:0] B;      // Input operand\n";
  fprintf fd "output [Y_WIDTH-1:0] X;     // A xor B (sign-extended, optional B inversion,\n";
  fprintf fd "                            //          used in combination with\n";
  fprintf fd "                            //          reduction-AND for $eq/$ne ops)\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;     // Sum\n";
  fprintf fd "\n";
  fprintf fd "input CI;                   // Carry-in (set for $sub)\n";
  fprintf fd "input BI;                   // Invert-B (set for $sub)\n";
  fprintf fd "output [Y_WIDTH-1:0] CO;    // Carry-out\n";
  fprintf fd "\n";
  fprintf fd "wire [Y_WIDTH-1:0] AA, BB;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign AA = $signed(A), BB = BI ? ~$signed(B) : $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign AA = $unsigned(A), BB = BI ? ~$unsigned(B) : $unsigned(B);\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "// this is 'x' if Y and CO should be all 'x', and '0' otherwise\n";
  fprintf fd "wire y_co_undef = ^{A, A, B, B, CI, CI, BI, BI};\n";
  fprintf fd "\n";
  fprintf fd "assign X = AA ^ BB;\n";
  fprintf fd "// Full adder\n";
  fprintf fd "assign Y = (AA + BB + CI) ^ {Y_WIDTH{y_co_undef}};\n";
  fprintf fd "\n";
  fprintf fd "function get_carry;\n";
  fprintf fd "	input a, b, c;\n";
  fprintf fd "	get_carry = (a&b) | (a&c) | (b&c);\n";
  fprintf fd "endfunction\n";
  fprintf fd "\n";
  fprintf fd "genvar i;\n";
  fprintf fd "generate\n";
  fprintf fd "	assign CO[0] = get_carry(AA[0], BB[0], CI) ^ y_co_undef;\n";
  fprintf fd "	for (i = 1; i < Y_WIDTH; i = i+1) begin:BLOCK3\n";
  fprintf fd "		assign CO[i] = get_carry(AA[i], BB[i], CO[i-1]) ^ y_co_undef;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$lt (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) < $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A < B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$le (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) <= $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A <= B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$eq (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) == $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A == B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$ne (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) != $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A != B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$eqx (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) === $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A === B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$nex (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) !== $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A !== B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$ge (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) >= $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A >= B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$gt (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) > $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A > B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$add (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) + $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A + B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$sub (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) - $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A - B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$mul (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) * $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A * B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$macc (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "parameter CONFIG = 4'b0000;\n";
  fprintf fd "parameter CONFIG_WIDTH = 4;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output reg [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "// Xilinx XSIM does not like $clog2() below..\n";
  fprintf fd "function integer my_clog2;\n";
  fprintf fd "	input integer v;\n";
  fprintf fd "	begin\n";
  fprintf fd "		if (v > 0)\n";
  fprintf fd "			v = v - 1;\n";
  fprintf fd "		my_clog2 = 0;\n";
  fprintf fd "		while (v) begin\n";
  fprintf fd "			v = v >> 1;\n";
  fprintf fd "			my_clog2 = my_clog2 + 1;\n";
  fprintf fd "		end\n";
  fprintf fd "	end\n";
  fprintf fd "endfunction\n";
  fprintf fd "\n";
  fprintf fd "localparam integer num_bits = CONFIG[3:0] > 0 ? CONFIG[3:0] : 1;\n";
  fprintf fd "localparam integer num_ports = (CONFIG_WIDTH-4) / (2 + 2*num_bits);\n";
  fprintf fd "localparam integer num_abits = my_clog2(A_WIDTH) > 0 ? my_clog2(A_WIDTH) : 1;\n";
  fprintf fd "\n";
  fprintf fd "function [2*num_ports*num_abits-1:0] get_port_offsets;\n";
  fprintf fd "	input [CONFIG_WIDTH-1:0] cfg;\n";
  fprintf fd "	integer i, cursor;\n";
  fprintf fd "	begin\n";
  fprintf fd "		cursor = 0;\n";
  fprintf fd "		get_port_offsets = 0;\n";
  fprintf fd "		for (i = 0; i < num_ports; i = i+1) begin\n";
  fprintf fd "			get_port_offsets[(2*i + 0)*num_abits +: num_abits] = cursor;\n";
  fprintf fd "			cursor = cursor + cfg[4 + i*(2 + 2*num_bits) + 2 +: num_bits];\n";
  fprintf fd "			get_port_offsets[(2*i + 1)*num_abits +: num_abits] = cursor;\n";
  fprintf fd "			cursor = cursor + cfg[4 + i*(2 + 2*num_bits) + 2 + num_bits +: num_bits];\n";
  fprintf fd "		end\n";
  fprintf fd "	end\n";
  fprintf fd "endfunction\n";
  fprintf fd "\n";
  fprintf fd "localparam [2*num_ports*num_abits-1:0] port_offsets = get_port_offsets(CONFIG);\n";
  fprintf fd "\n";
  fprintf fd "`define PORT_IS_SIGNED   (0 + CONFIG[4 + i*(2 + 2*num_bits)])\n";
  fprintf fd "`define PORT_DO_SUBTRACT (0 + CONFIG[4 + i*(2 + 2*num_bits) + 1])\n";
  fprintf fd "`define PORT_SIZE_A      (0 + CONFIG[4 + i*(2 + 2*num_bits) + 2 +: num_bits])\n";
  fprintf fd "`define PORT_SIZE_B      (0 + CONFIG[4 + i*(2 + 2*num_bits) + 2 + num_bits +: num_bits])\n";
  fprintf fd "`define PORT_OFFSET_A    (0 + port_offsets[2*i*num_abits +: num_abits])\n";
  fprintf fd "`define PORT_OFFSET_B    (0 + port_offsets[2*i*num_abits + num_abits +: num_abits])\n";
  fprintf fd "\n";
  fprintf fd "integer i, j;\n";
  fprintf fd "reg [Y_WIDTH-1:0] tmp_a, tmp_b;\n";
  fprintf fd "\n";
  fprintf fd "always @* begin\n";
  fprintf fd "	Y = 0;\n";
  fprintf fd "	for (i = 0; i < num_ports; i = i+1)\n";
  fprintf fd "	begin\n";
  fprintf fd "		tmp_a = 0;\n";
  fprintf fd "		tmp_b = 0;\n";
  fprintf fd "\n";
  fprintf fd "		for (j = 0; j < `PORT_SIZE_A; j = j+1)\n";
  fprintf fd "			tmp_a[j] = A[`PORT_OFFSET_A + j];\n";
  fprintf fd "\n";
  fprintf fd "		if (`PORT_IS_SIGNED && `PORT_SIZE_A > 0)\n";
  fprintf fd "			for (j = `PORT_SIZE_A; j < Y_WIDTH; j = j+1)\n";
  fprintf fd "				tmp_a[j] = tmp_a[`PORT_SIZE_A-1];\n";
  fprintf fd "\n";
  fprintf fd "		for (j = 0; j < `PORT_SIZE_B; j = j+1)\n";
  fprintf fd "			tmp_b[j] = A[`PORT_OFFSET_B + j];\n";
  fprintf fd "\n";
  fprintf fd "		if (`PORT_IS_SIGNED && `PORT_SIZE_B > 0)\n";
  fprintf fd "			for (j = `PORT_SIZE_B; j < Y_WIDTH; j = j+1)\n";
  fprintf fd "				tmp_b[j] = tmp_b[`PORT_SIZE_B-1];\n";
  fprintf fd "\n";
  fprintf fd "		if (`PORT_SIZE_B > 0)\n";
  fprintf fd "			tmp_a = tmp_a * tmp_b;\n";
  fprintf fd "\n";
  fprintf fd "		if (`PORT_DO_SUBTRACT)\n";
  fprintf fd "			Y = Y - tmp_a;\n";
  fprintf fd "		else\n";
  fprintf fd "			Y = Y + tmp_a;\n";
  fprintf fd "	end\n";
  fprintf fd "	for (i = 0; i < B_WIDTH; i = i+1) begin\n";
  fprintf fd "		Y = Y + B[i];\n";
  fprintf fd "	end\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "`undef PORT_IS_SIGNED\n";
  fprintf fd "`undef PORT_DO_SUBTRACT\n";
  fprintf fd "`undef PORT_SIZE_A\n";
  fprintf fd "`undef PORT_SIZE_B\n";
  fprintf fd "`undef PORT_OFFSET_A\n";
  fprintf fd "`undef PORT_OFFSET_B\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $div (A, B, Y)\n";
  fprintf fd "//-\n";
  fprintf fd "//- Division with truncated result (rounded towards 0).\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$div (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) / $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A / B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $mod (A, B, Y)\n";
  fprintf fd "//-\n";
  fprintf fd "//- Modulo/remainder of division with truncated result (rounded towards 0).\n";
  fprintf fd "//-\n";
  fprintf fd "//- Invariant: $div(A, B) * B + $mod(A, B) == A\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$mod (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) %% $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A %% B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $divfloor (A, B, Y)\n";
  fprintf fd "//-\n";
  fprintf fd "//- Division with floored result (rounded towards negative infinity).\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$divfloor (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		localparam WIDTH =\n";
  fprintf fd "				A_WIDTH >= B_WIDTH && A_WIDTH >= Y_WIDTH ? A_WIDTH :\n";
  fprintf fd "				B_WIDTH >= A_WIDTH && B_WIDTH >= Y_WIDTH ? B_WIDTH : Y_WIDTH;\n";
  fprintf fd "		wire [WIDTH:0] A_buf, B_buf, N_buf;\n";
  fprintf fd "		assign A_buf = $signed(A);\n";
  fprintf fd "		assign B_buf = $signed(B);\n";
  fprintf fd "		assign N_buf = (A[A_WIDTH-1] == B[B_WIDTH-1]) || A == 0 ? A_buf : $signed(A_buf - (B[B_WIDTH-1] ? B_buf+1 : B_buf-1));\n";
  fprintf fd "		assign Y = $signed(N_buf) / $signed(B_buf);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A / B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\n";
  fprintf fd "//-\n";
  fprintf fd "//-     $modfloor (A, B, Y)\n";
  fprintf fd "//-\n";
  fprintf fd "//- Modulo/remainder of division with floored result (rounded towards negative infinity).\n";
  fprintf fd "//-\n";
  fprintf fd "//- Invariant: $divfloor(A, B) * B + $modfloor(A, B) == A\n";
  fprintf fd "//-\n";
  fprintf fd "module \\$modfloor (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		localparam WIDTH = B_WIDTH >= Y_WIDTH ? B_WIDTH : Y_WIDTH;\n";
  fprintf fd "		wire [WIDTH-1:0] B_buf, Y_trunc;\n";
  fprintf fd "		assign B_buf = $signed(B);\n";
  fprintf fd "		assign Y_trunc = $signed(A) %% $signed(B);\n";
  fprintf fd "		// flooring mod is the same as truncating mod for positive division results (A and B have\n";
  fprintf fd "		// the same sign), as well as when there's no remainder.\n";
  fprintf fd "		// For all other cases, they behave as `floor - trunc = B`\n";
  fprintf fd "		assign Y = (A[A_WIDTH-1] == B[B_WIDTH-1]) || Y_trunc == 0 ? Y_trunc : $signed(B_buf) + $signed(Y_trunc);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		// no difference between truncating and flooring for unsigned\n";
  fprintf fd "		assign Y = A %% B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "`ifndef SIMLIB_NOPOW\n";
  fprintf fd "\n";
  fprintf fd "module \\$pow (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) ** $signed(B);\n";
  fprintf fd "	end else if (A_SIGNED) begin:BLOCK2\n";
  fprintf fd "		assign Y = $signed(A) ** B;\n";
  fprintf fd "	end else if (B_SIGNED) begin:BLOCK3\n";
  fprintf fd "		assign Y = A ** $signed(B);\n";
  fprintf fd "	end else begin:BLOCK4\n";
  fprintf fd "		assign Y = A ** B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "`endif\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$logic_not (A, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = !$signed(A);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = !A;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$logic_and (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) && $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A && B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$logic_or (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_SIGNED = 0;\n";
  fprintf fd "parameter B_SIGNED = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (A_SIGNED && B_SIGNED) begin:BLOCK1\n";
  fprintf fd "		assign Y = $signed(A) || $signed(B);\n";
  fprintf fd "	end else begin:BLOCK2\n";
  fprintf fd "		assign Y = A || B;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$slice (A, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter OFFSET = 0;\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter Y_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "output [Y_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "assign Y = A >> OFFSET;\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$concat (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter A_WIDTH = 0;\n";
  fprintf fd "parameter B_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [A_WIDTH-1:0] A;\n";
  fprintf fd "input [B_WIDTH-1:0] B;\n";
  fprintf fd "output [A_WIDTH+B_WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "assign Y = {B, A};\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$mux (A, B, S, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [WIDTH-1:0] A, B;\n";
  fprintf fd "input S;\n";
  fprintf fd "output reg [WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "always @* begin\n";
  fprintf fd "	if (S)\n";
  fprintf fd "		Y = B;\n";
  fprintf fd "	else\n";
  fprintf fd "		Y = A;\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$pmux (A, B, S, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "parameter S_WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [WIDTH-1:0] A;\n";
  fprintf fd "input [WIDTH*S_WIDTH-1:0] B;\n";
  fprintf fd "input [S_WIDTH-1:0] S;\n";
  fprintf fd "output reg [WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "integer i;\n";
  fprintf fd "reg found_active_sel_bit;\n";
  fprintf fd "\n";
  fprintf fd "always @* begin\n";
  fprintf fd "	Y = A;\n";
  fprintf fd "	found_active_sel_bit = 0;\n";
  fprintf fd "	for (i = 0; i < S_WIDTH; i = i+1)\n";
  fprintf fd "		if (S[i]) begin\n";
  fprintf fd "			Y = found_active_sel_bit ? 'bx : B >> (WIDTH*i);\n";
  fprintf fd "			found_active_sel_bit = 1;\n";
  fprintf fd "		end\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "`ifndef SIMLIB_NOLUT\n";
  fprintf fd "\n";
  fprintf fd "module \\$lut (A, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "parameter LUT = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [WIDTH-1:0] A;\n";
  fprintf fd "output reg Y;\n";
  fprintf fd "\n";
  fprintf fd "wire lut0_out, lut1_out;\n";
  fprintf fd "\n";
  fprintf fd "generate\n";
  fprintf fd "	if (WIDTH <= 1) begin:simple\n";
  fprintf fd "		assign {lut1_out, lut0_out} = LUT;\n";
  fprintf fd "	end else begin:complex\n";
  fprintf fd "		\\$lut #( .WIDTH(WIDTH-1), .LUT(LUT                  ) ) lut0 ( .A(A[WIDTH-2:0]), .Y(lut0_out) );\n";
  fprintf fd "		\\$lut #( .WIDTH(WIDTH-1), .LUT(LUT >> (2**(WIDTH-1))) ) lut1 ( .A(A[WIDTH-2:0]), .Y(lut1_out) );\n";
  fprintf fd "	end\n";
  fprintf fd "\n";
  fprintf fd "	if (WIDTH > 0) begin:lutlogic\n";
  fprintf fd "		always @* begin\n";
  fprintf fd "			casez ({A[WIDTH-1], lut0_out, lut1_out})\n";
  fprintf fd "				3'b?11: Y = 1'b1;\n";
  fprintf fd "				3'b?00: Y = 1'b0;\n";
  fprintf fd "				3'b0??: Y = lut0_out;\n";
  fprintf fd "				3'b1??: Y = lut1_out;\n";
  fprintf fd "				default: Y = 1'bx;\n";
  fprintf fd "			endcase\n";
  fprintf fd "		end\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "`endif\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$sop (A, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "parameter DEPTH = 0;\n";
  fprintf fd "parameter TABLE = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [WIDTH-1:0] A;\n";
  fprintf fd "output reg Y;\n";
  fprintf fd "\n";
  fprintf fd "integer i, j;\n";
  fprintf fd "reg match;\n";
  fprintf fd "\n";
  fprintf fd "always @* begin\n";
  fprintf fd "	Y = 0;\n";
  fprintf fd "	for (i = 0; i < DEPTH; i=i+1) begin\n";
  fprintf fd "		match = 1;\n";
  fprintf fd "		for (j = 0; j < WIDTH; j=j+1) begin\n";
  fprintf fd "			if (TABLE[2*WIDTH*i + 2*j + 0] && A[j]) match = 0;\n";
  fprintf fd "			if (TABLE[2*WIDTH*i + 2*j + 1] && !A[j]) match = 0;\n";
  fprintf fd "		end\n";
  fprintf fd "		if (match) Y = 1;\n";
  fprintf fd "	end\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
(*
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$tribuf (A, EN, Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [WIDTH-1:0] A;\n";
  fprintf fd "input EN;\n";
  fprintf fd "output [WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "assign Y = EN ? A : 'bz;\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
*)
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$specify2 (EN, SRC, DST);\n";
  fprintf fd "\n";
  fprintf fd "parameter FULL = 0;\n";
  fprintf fd "parameter SRC_WIDTH = 1;\n";
  fprintf fd "parameter DST_WIDTH = 1;\n";
  fprintf fd "\n";
  fprintf fd "parameter SRC_DST_PEN = 0;\n";
  fprintf fd "parameter SRC_DST_POL = 0;\n";
  fprintf fd "\n";
  fprintf fd "parameter T_RISE_MIN = 0;\n";
  fprintf fd "parameter T_RISE_TYP = 0;\n";
  fprintf fd "parameter T_RISE_MAX = 0;\n";
  fprintf fd "\n";
  fprintf fd "parameter T_FALL_MIN = 0;\n";
  fprintf fd "parameter T_FALL_TYP = 0;\n";
  fprintf fd "parameter T_FALL_MAX = 0;\n";
  fprintf fd "\n";
  fprintf fd "input EN;\n";
  fprintf fd "input [SRC_WIDTH-1:0] SRC;\n";
  fprintf fd "input [DST_WIDTH-1:0] DST;\n";
  fprintf fd "\n";
  fprintf fd "localparam SD = SRC_DST_PEN ? (SRC_DST_POL ? 1 : 2) : 0;\n";
  fprintf fd "\n";
  fprintf fd "`ifdef SIMLIB_SPECIFY\n";
  fprintf fd "specify\n";
  fprintf fd "	if (EN && SD==0 && !FULL) (SRC  => DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && SD==0 &&  FULL) (SRC  *> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && SD==1 && !FULL) (SRC +=> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && SD==1 &&  FULL) (SRC +*> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && SD==2 && !FULL) (SRC -=> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && SD==2 &&  FULL) (SRC -*> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "endspecify\n";
  fprintf fd "`endif\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$specify3 (EN, SRC, DST, DAT);\n";
  fprintf fd "\n";
  fprintf fd "parameter FULL = 0;\n";
  fprintf fd "parameter SRC_WIDTH = 1;\n";
  fprintf fd "parameter DST_WIDTH = 1;\n";
  fprintf fd "\n";
  fprintf fd "parameter EDGE_EN = 0;\n";
  fprintf fd "parameter EDGE_POL = 0;\n";
  fprintf fd "\n";
  fprintf fd "parameter SRC_DST_PEN = 0;\n";
  fprintf fd "parameter SRC_DST_POL = 0;\n";
  fprintf fd "\n";
  fprintf fd "parameter DAT_DST_PEN = 0;\n";
  fprintf fd "parameter DAT_DST_POL = 0;\n";
  fprintf fd "\n";
  fprintf fd "parameter T_RISE_MIN = 0;\n";
  fprintf fd "parameter T_RISE_TYP = 0;\n";
  fprintf fd "parameter T_RISE_MAX = 0;\n";
  fprintf fd "\n";
  fprintf fd "parameter T_FALL_MIN = 0;\n";
  fprintf fd "parameter T_FALL_TYP = 0;\n";
  fprintf fd "parameter T_FALL_MAX = 0;\n";
  fprintf fd "\n";
  fprintf fd "input EN;\n";
  fprintf fd "input [SRC_WIDTH-1:0] SRC;\n";
  fprintf fd "input [DST_WIDTH-1:0] DST, DAT;\n";
  fprintf fd "\n";
  fprintf fd "localparam ED = EDGE_EN     ? (EDGE_POL    ? 1 : 2) : 0;\n";
  fprintf fd "localparam SD = SRC_DST_PEN ? (SRC_DST_POL ? 1 : 2) : 0;\n";
  fprintf fd "localparam DD = DAT_DST_PEN ? (DAT_DST_POL ? 1 : 2) : 0;\n";
  fprintf fd "\n";
  fprintf fd "`ifdef SIMLIB_SPECIFY\n";
  fprintf fd "specify\n";
  fprintf fd "	// DD=0\n";
  fprintf fd "\n";
  fprintf fd "	if (EN && DD==0 && SD==0 && ED==0 && !FULL) (        SRC  => (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==0 && SD==0 && ED==0 &&  FULL) (        SRC  *> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==0 && SD==0 && ED==1 && !FULL) (posedge SRC  => (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==0 && SD==0 && ED==1 &&  FULL) (posedge SRC  *> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==0 && SD==0 && ED==2 && !FULL) (negedge SRC  => (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==0 && SD==0 && ED==2 &&  FULL) (negedge SRC  *> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "\n";
  fprintf fd "	if (EN && DD==0 && SD==1 && ED==0 && !FULL) (        SRC +=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==0 && SD==1 && ED==0 &&  FULL) (        SRC +*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==0 && SD==1 && ED==1 && !FULL) (posedge SRC +=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==0 && SD==1 && ED==1 &&  FULL) (posedge SRC +*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==0 && SD==1 && ED==2 && !FULL) (negedge SRC +=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==0 && SD==1 && ED==2 &&  FULL) (negedge SRC +*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "\n";
  fprintf fd "	if (EN && DD==0 && SD==2 && ED==0 && !FULL) (        SRC -=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==0 && SD==2 && ED==0 &&  FULL) (        SRC -*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==0 && SD==2 && ED==1 && !FULL) (posedge SRC -=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==0 && SD==2 && ED==1 &&  FULL) (posedge SRC -*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==0 && SD==2 && ED==2 && !FULL) (negedge SRC -=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==0 && SD==2 && ED==2 &&  FULL) (negedge SRC -*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "\n";
  fprintf fd "	// DD=1\n";
  fprintf fd "\n";
  fprintf fd "	if (EN && DD==1 && SD==0 && ED==0 && !FULL) (        SRC  => (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==1 && SD==0 && ED==0 &&  FULL) (        SRC  *> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==1 && SD==0 && ED==1 && !FULL) (posedge SRC  => (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==1 && SD==0 && ED==1 &&  FULL) (posedge SRC  *> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==1 && SD==0 && ED==2 && !FULL) (negedge SRC  => (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==1 && SD==0 && ED==2 &&  FULL) (negedge SRC  *> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "\n";
  fprintf fd "	if (EN && DD==1 && SD==1 && ED==0 && !FULL) (        SRC +=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==1 && SD==1 && ED==0 &&  FULL) (        SRC +*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==1 && SD==1 && ED==1 && !FULL) (posedge SRC +=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==1 && SD==1 && ED==1 &&  FULL) (posedge SRC +*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==1 && SD==1 && ED==2 && !FULL) (negedge SRC +=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==1 && SD==1 && ED==2 &&  FULL) (negedge SRC +*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "\n";
  fprintf fd "	if (EN && DD==1 && SD==2 && ED==0 && !FULL) (        SRC -=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==1 && SD==2 && ED==0 &&  FULL) (        SRC -*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==1 && SD==2 && ED==1 && !FULL) (posedge SRC -=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==1 && SD==2 && ED==1 &&  FULL) (posedge SRC -*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==1 && SD==2 && ED==2 && !FULL) (negedge SRC -=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==1 && SD==2 && ED==2 &&  FULL) (negedge SRC -*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "\n";
  fprintf fd "	// DD=2\n";
  fprintf fd "\n";
  fprintf fd "	if (EN && DD==2 && SD==0 && ED==0 && !FULL) (        SRC  => (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==2 && SD==0 && ED==0 &&  FULL) (        SRC  *> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==2 && SD==0 && ED==1 && !FULL) (posedge SRC  => (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==2 && SD==0 && ED==1 &&  FULL) (posedge SRC  *> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==2 && SD==0 && ED==2 && !FULL) (negedge SRC  => (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==2 && SD==0 && ED==2 &&  FULL) (negedge SRC  *> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "\n";
  fprintf fd "	if (EN && DD==2 && SD==1 && ED==0 && !FULL) (        SRC +=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==2 && SD==1 && ED==0 &&  FULL) (        SRC +*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==2 && SD==1 && ED==1 && !FULL) (posedge SRC +=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==2 && SD==1 && ED==1 &&  FULL) (posedge SRC +*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==2 && SD==1 && ED==2 && !FULL) (negedge SRC +=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==2 && SD==1 && ED==2 &&  FULL) (negedge SRC +*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "\n";
  fprintf fd "	if (EN && DD==2 && SD==2 && ED==0 && !FULL) (        SRC -=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==2 && SD==2 && ED==0 &&  FULL) (        SRC -*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==2 && SD==2 && ED==1 && !FULL) (posedge SRC -=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==2 && SD==2 && ED==1 &&  FULL) (posedge SRC -*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==2 && SD==2 && ED==2 && !FULL) (negedge SRC -=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "	if (EN && DD==2 && SD==2 && ED==2 &&  FULL) (negedge SRC -*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n";
  fprintf fd "endspecify\n";
  fprintf fd "`endif\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$specrule (EN_SRC, EN_DST, SRC, DST);\n";
  fprintf fd "\n";
  fprintf fd "parameter TYPE = \"\";\n";
  fprintf fd "parameter T_LIMIT = 0;\n";
  fprintf fd "parameter T_LIMIT2 = 0;\n";
  fprintf fd "\n";
  fprintf fd "parameter SRC_WIDTH = 1;\n";
  fprintf fd "parameter DST_WIDTH = 1;\n";
  fprintf fd "\n";
  fprintf fd "parameter SRC_PEN = 0;\n";
  fprintf fd "parameter SRC_POL = 0;\n";
  fprintf fd "\n";
  fprintf fd "parameter DST_PEN = 0;\n";
  fprintf fd "parameter DST_POL = 0;\n";
  fprintf fd "\n";
  fprintf fd "input EN_SRC, EN_DST;\n";
  fprintf fd "input [SRC_WIDTH-1:0] SRC;\n";
  fprintf fd "input [DST_WIDTH-1:0] DST;\n";
  fprintf fd "\n";
  fprintf fd "`ifdef SIMLIB_SPECIFY\n";
  fprintf fd "specify\n";
  fprintf fd "	// TBD\n";
  fprintf fd "endspecify\n";
  fprintf fd "`endif\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
(*
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$assert (A, EN);\n";
  fprintf fd "\n";
  fprintf fd "input A, EN;\n";
  fprintf fd "\n";
  fprintf fd "`ifndef SIMLIB_NOCHECKS\n";
  fprintf fd "always @* begin\n";
  fprintf fd "	if (A !== 1'b1 && EN === 1'b1) begin\n";
  fprintf fd "		$display(\"Assertion %%m failed!\");\n";
  fprintf fd "		$stop;\n";
  fprintf fd "	end\n";
  fprintf fd "end\n";
  fprintf fd "`endif\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$assume (A, EN);\n";
  fprintf fd "\n";
  fprintf fd "input A, EN;\n";
  fprintf fd "\n";
  fprintf fd "`ifndef SIMLIB_NOCHECKS\n";
  fprintf fd "always @* begin\n";
  fprintf fd "	if (A !== 1'b1 && EN === 1'b1) begin\n";
  fprintf fd "		$display(\"Assumption %%m failed!\");\n";
  fprintf fd "		$stop;\n";
  fprintf fd "	end\n";
  fprintf fd "end\n";
  fprintf fd "`endif\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
*)
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$live (A, EN);\n";
  fprintf fd "\n";
  fprintf fd "input A, EN;\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$fair (A, EN);\n";
  fprintf fd "\n";
  fprintf fd "input A, EN;\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$cover (A, EN);\n";
  fprintf fd "\n";
  fprintf fd "input A, EN;\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
(*
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$initstate (Y);\n";
  fprintf fd "\n";
  fprintf fd "output reg Y = 1;\n";
  fprintf fd "reg [3:0] cnt = 1;\n";
  fprintf fd "reg trig = 0;\n";
  fprintf fd "\n";
  fprintf fd "initial trig <= 1;\n";
  fprintf fd "\n";
  fprintf fd "always @(cnt, trig) begin\n";
  fprintf fd "	Y <= |cnt;\n";
  fprintf fd "	cnt <= cnt + |cnt;\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
*)
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$anyconst (Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "output [WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "assign Y = 'bx;\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$anyseq (Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "output [WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "assign Y = 'bx;\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$allconst (Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "output [WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "assign Y = 'bx;\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$allseq (Y);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "output [WIDTH-1:0] Y;\n";
  fprintf fd "\n";
  fprintf fd "assign Y = 'bx;\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
(*
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$equiv (A, B, Y);\n";
  fprintf fd "\n";
  fprintf fd "input A, B;\n";
  fprintf fd "output Y;\n";
  fprintf fd "\n";
  fprintf fd "assign Y = (A !== 1'bx && A !== B) ? 1'bx : A;\n";
  fprintf fd "\n";
  fprintf fd "`ifndef SIMLIB_NOCHECKS\n";
  fprintf fd "always @* begin\n";
  fprintf fd "	if (A !== 1'bx && A !== B) begin\n";
  fprintf fd "		$display(\"Equivalence failed!\");\n";
  fprintf fd "		$stop;\n";
  fprintf fd "	end\n";
  fprintf fd "end\n";
  fprintf fd "`endif\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
*)
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "`ifndef SIMLIB_NOSR\n";
  fprintf fd "\n";
  fprintf fd "module \\$sr (SET, CLR, Q);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "parameter SET_POLARITY = 1'b1;\n";
  fprintf fd "parameter CLR_POLARITY = 1'b1;\n";
  fprintf fd "\n";
  fprintf fd "input [WIDTH-1:0] SET, CLR;\n";
  fprintf fd "output reg [WIDTH-1:0] Q;\n";
  fprintf fd "\n";
  fprintf fd "wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;\n";
  fprintf fd "wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;\n";
  fprintf fd "\n";
  fprintf fd "genvar i;\n";
  fprintf fd "generate\n";
  fprintf fd "	for (i = 0; i < WIDTH; i = i+1) begin:bitslices\n";
  fprintf fd "		always @*\n";
  fprintf fd "			if (pos_clr[i])\n";
  fprintf fd "				Q[i] <= 0;\n";
  fprintf fd "			else if (pos_set[i])\n";
  fprintf fd "				Q[i] <= 1;\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "`endif\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "`ifdef SIMLIB_FF\n";
  fprintf fd "\n";
  fprintf fd "module \\$ff (D, Q);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [WIDTH-1:0] D;\n";
  fprintf fd "output reg [WIDTH-1:0] Q;\n";
  fprintf fd "\n";
  fprintf fd "always @($global_clk) begin\n";
  fprintf fd "	Q <= D;\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "`endif\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$dff (CLK, D, Q);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "parameter CLK_POLARITY = 1'b1;\n";
  fprintf fd "\n";
  fprintf fd "input CLK;\n";
  fprintf fd "input [WIDTH-1:0] D;\n";
  fprintf fd "output reg [WIDTH-1:0] Q;\n";
  fprintf fd "wire pos_clk = CLK == CLK_POLARITY;\n";
  fprintf fd "\n";
  fprintf fd "always @(posedge pos_clk) begin\n";
  fprintf fd "	Q <= D;\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$dffe (CLK, EN, D, Q);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "parameter CLK_POLARITY = 1'b1;\n";
  fprintf fd "parameter EN_POLARITY = 1'b1;\n";
  fprintf fd "\n";
  fprintf fd "input CLK, EN;\n";
  fprintf fd "input [WIDTH-1:0] D;\n";
  fprintf fd "output reg [WIDTH-1:0] Q;\n";
  fprintf fd "wire pos_clk = CLK == CLK_POLARITY;\n";
  fprintf fd "\n";
  fprintf fd "always @(posedge pos_clk) begin\n";
  fprintf fd "	if (EN == EN_POLARITY) Q <= D;\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "`ifndef SIMLIB_NOSR\n";
  fprintf fd "\n";
  fprintf fd "module \\$dffsr (CLK, SET, CLR, D, Q);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "parameter CLK_POLARITY = 1'b1;\n";
  fprintf fd "parameter SET_POLARITY = 1'b1;\n";
  fprintf fd "parameter CLR_POLARITY = 1'b1;\n";
  fprintf fd "\n";
  fprintf fd "input CLK;\n";
  fprintf fd "input [WIDTH-1:0] SET, CLR, D;\n";
  fprintf fd "output reg [WIDTH-1:0] Q;\n";
  fprintf fd "\n";
  fprintf fd "wire pos_clk = CLK == CLK_POLARITY;\n";
  fprintf fd "wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;\n";
  fprintf fd "wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;\n";
  fprintf fd "\n";
  fprintf fd "genvar i;\n";
  fprintf fd "generate\n";
  fprintf fd "	for (i = 0; i < WIDTH; i = i+1) begin:bitslices\n";
  fprintf fd "		always @(posedge pos_set[i], posedge pos_clr[i], posedge pos_clk)\n";
  fprintf fd "			if (pos_clr[i])\n";
  fprintf fd "				Q[i] <= 0;\n";
  fprintf fd "			else if (pos_set[i])\n";
  fprintf fd "				Q[i] <= 1;\n";
  fprintf fd "			else\n";
  fprintf fd "				Q[i] <= D[i];\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$dffsre (CLK, SET, CLR, EN, D, Q);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "parameter CLK_POLARITY = 1'b1;\n";
  fprintf fd "parameter SET_POLARITY = 1'b1;\n";
  fprintf fd "parameter CLR_POLARITY = 1'b1;\n";
  fprintf fd "parameter EN_POLARITY = 1'b1;\n";
  fprintf fd "\n";
  fprintf fd "input CLK, EN;\n";
  fprintf fd "input [WIDTH-1:0] SET, CLR, D;\n";
  fprintf fd "output reg [WIDTH-1:0] Q;\n";
  fprintf fd "\n";
  fprintf fd "wire pos_clk = CLK == CLK_POLARITY;\n";
  fprintf fd "wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;\n";
  fprintf fd "wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;\n";
  fprintf fd "\n";
  fprintf fd "genvar i;\n";
  fprintf fd "generate\n";
  fprintf fd "	for (i = 0; i < WIDTH; i = i+1) begin:bitslices\n";
  fprintf fd "		always @(posedge pos_set[i], posedge pos_clr[i], posedge pos_clk)\n";
  fprintf fd "			if (pos_clr[i])\n";
  fprintf fd "				Q[i] <= 0;\n";
  fprintf fd "			else if (pos_set[i])\n";
  fprintf fd "				Q[i] <= 1;\n";
  fprintf fd "			else if (EN == EN_POLARITY)\n";
  fprintf fd "				Q[i] <= D[i];\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "`endif\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$adff (CLK, ARST, D, Q);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "parameter CLK_POLARITY = 1'b1;\n";
  fprintf fd "parameter ARST_POLARITY = 1'b1;\n";
  fprintf fd "parameter ARST_VALUE = 0;\n";
  fprintf fd "\n";
  fprintf fd "input CLK, ARST;\n";
  fprintf fd "input [WIDTH-1:0] D;\n";
  fprintf fd "output reg [WIDTH-1:0] Q;\n";
  fprintf fd "wire pos_clk = CLK == CLK_POLARITY;\n";
  fprintf fd "wire pos_arst = ARST == ARST_POLARITY;\n";
  fprintf fd "\n";
  fprintf fd "always @(posedge pos_clk, posedge pos_arst) begin\n";
  fprintf fd "	if (pos_arst)\n";
  fprintf fd "		Q <= ARST_VALUE;\n";
  fprintf fd "	else\n";
  fprintf fd "		Q <= D;\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$sdff (CLK, SRST, D, Q);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "parameter CLK_POLARITY = 1'b1;\n";
  fprintf fd "parameter SRST_POLARITY = 1'b1;\n";
  fprintf fd "parameter SRST_VALUE = 0;\n";
  fprintf fd "\n";
  fprintf fd "input CLK, SRST;\n";
  fprintf fd "input [WIDTH-1:0] D;\n";
  fprintf fd "output reg [WIDTH-1:0] Q;\n";
  fprintf fd "wire pos_clk = CLK == CLK_POLARITY;\n";
  fprintf fd "wire pos_srst = SRST == SRST_POLARITY;\n";
  fprintf fd "\n";
  fprintf fd "always @(posedge pos_clk) begin\n";
  fprintf fd "	if (pos_srst)\n";
  fprintf fd "		Q <= SRST_VALUE;\n";
  fprintf fd "	else\n";
  fprintf fd "		Q <= D;\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$adffe (CLK, ARST, EN, D, Q);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "parameter CLK_POLARITY = 1'b1;\n";
  fprintf fd "parameter EN_POLARITY = 1'b1;\n";
  fprintf fd "parameter ARST_POLARITY = 1'b1;\n";
  fprintf fd "parameter ARST_VALUE = 0;\n";
  fprintf fd "\n";
  fprintf fd "input CLK, ARST, EN;\n";
  fprintf fd "input [WIDTH-1:0] D;\n";
  fprintf fd "output reg [WIDTH-1:0] Q;\n";
  fprintf fd "wire pos_clk = CLK == CLK_POLARITY;\n";
  fprintf fd "wire pos_arst = ARST == ARST_POLARITY;\n";
  fprintf fd "\n";
  fprintf fd "always @(posedge pos_clk, posedge pos_arst) begin\n";
  fprintf fd "	if (pos_arst)\n";
  fprintf fd "		Q <= ARST_VALUE;\n";
  fprintf fd "	else if (EN == EN_POLARITY)\n";
  fprintf fd "		Q <= D;\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$sdffe (CLK, SRST, EN, D, Q);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "parameter CLK_POLARITY = 1'b1;\n";
  fprintf fd "parameter EN_POLARITY = 1'b1;\n";
  fprintf fd "parameter SRST_POLARITY = 1'b1;\n";
  fprintf fd "parameter SRST_VALUE = 0;\n";
  fprintf fd "\n";
  fprintf fd "input CLK, SRST, EN;\n";
  fprintf fd "input [WIDTH-1:0] D;\n";
  fprintf fd "output reg [WIDTH-1:0] Q;\n";
  fprintf fd "wire pos_clk = CLK == CLK_POLARITY;\n";
  fprintf fd "wire pos_srst = SRST == SRST_POLARITY;\n";
  fprintf fd "\n";
  fprintf fd "always @(posedge pos_clk) begin\n";
  fprintf fd "	if (pos_srst)\n";
  fprintf fd "		Q <= SRST_VALUE;\n";
  fprintf fd "	else if (EN == EN_POLARITY)\n";
  fprintf fd "		Q <= D;\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$sdffce (CLK, SRST, EN, D, Q);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "parameter CLK_POLARITY = 1'b1;\n";
  fprintf fd "parameter EN_POLARITY = 1'b1;\n";
  fprintf fd "parameter SRST_POLARITY = 1'b1;\n";
  fprintf fd "parameter SRST_VALUE = 0;\n";
  fprintf fd "\n";
  fprintf fd "input CLK, SRST, EN;\n";
  fprintf fd "input [WIDTH-1:0] D;\n";
  fprintf fd "output reg [WIDTH-1:0] Q;\n";
  fprintf fd "wire pos_clk = CLK == CLK_POLARITY;\n";
  fprintf fd "wire pos_srst = SRST == SRST_POLARITY;\n";
  fprintf fd "\n";
  fprintf fd "always @(posedge pos_clk) begin\n";
  fprintf fd "	if (EN == EN_POLARITY) begin\n";
  fprintf fd "		if (pos_srst)\n";
  fprintf fd "			Q <= SRST_VALUE;\n";
  fprintf fd "		else\n";
  fprintf fd "			Q <= D;\n";
  fprintf fd "	end\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$dlatch (EN, D, Q);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "parameter EN_POLARITY = 1'b1;\n";
  fprintf fd "\n";
  fprintf fd "input EN;\n";
  fprintf fd "input [WIDTH-1:0] D;\n";
  fprintf fd "output reg [WIDTH-1:0] Q;\n";
  fprintf fd "\n";
  fprintf fd "always @* begin\n";
  fprintf fd "	if (EN == EN_POLARITY)\n";
  fprintf fd "		Q = D;\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$adlatch (EN, ARST, D, Q);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "parameter EN_POLARITY = 1'b1;\n";
  fprintf fd "parameter ARST_POLARITY = 1'b1;\n";
  fprintf fd "parameter ARST_VALUE = 0;\n";
  fprintf fd "\n";
  fprintf fd "input EN, ARST;\n";
  fprintf fd "input [WIDTH-1:0] D;\n";
  fprintf fd "output reg [WIDTH-1:0] Q;\n";
  fprintf fd "\n";
  fprintf fd "always @* begin\n";
  fprintf fd "	if (ARST == ARST_POLARITY)\n";
  fprintf fd "		Q = ARST_VALUE;\n";
  fprintf fd "	else if (EN == EN_POLARITY)\n";
  fprintf fd "		Q = D;\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "`ifndef SIMLIB_NOSR\n";
  fprintf fd "\n";
  fprintf fd "module \\$dlatchsr (EN, SET, CLR, D, Q);\n";
  fprintf fd "\n";
  fprintf fd "parameter WIDTH = 0;\n";
  fprintf fd "parameter EN_POLARITY = 1'b1;\n";
  fprintf fd "parameter SET_POLARITY = 1'b1;\n";
  fprintf fd "parameter CLR_POLARITY = 1'b1;\n";
  fprintf fd "\n";
  fprintf fd "input EN;\n";
  fprintf fd "input [WIDTH-1:0] SET, CLR, D;\n";
  fprintf fd "output reg [WIDTH-1:0] Q;\n";
  fprintf fd "\n";
  fprintf fd "wire pos_en = EN == EN_POLARITY;\n";
  fprintf fd "wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;\n";
  fprintf fd "wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;\n";
  fprintf fd "\n";
  fprintf fd "genvar i;\n";
  fprintf fd "generate\n";
  fprintf fd "	for (i = 0; i < WIDTH; i = i+1) begin:bitslices\n";
  fprintf fd "		always @*\n";
  fprintf fd "			if (pos_clr[i])\n";
  fprintf fd "				Q[i] = 0;\n";
  fprintf fd "			else if (pos_set[i])\n";
  fprintf fd "				Q[i] = 1;\n";
  fprintf fd "			else if (pos_en)\n";
  fprintf fd "				Q[i] = D[i];\n";
  fprintf fd "	end\n";
  fprintf fd "endgenerate\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "`endif\n";
(*
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$fsm (CLK, ARST, CTRL_IN, CTRL_OUT);\n";
  fprintf fd "\n";
  fprintf fd "parameter NAME = \"\";\n";
  fprintf fd "\n";
  fprintf fd "parameter CLK_POLARITY = 1'b1;\n";
  fprintf fd "parameter ARST_POLARITY = 1'b1;\n";
  fprintf fd "\n";
  fprintf fd "parameter CTRL_IN_WIDTH = 1;\n";
  fprintf fd "parameter CTRL_OUT_WIDTH = 1;\n";
  fprintf fd "\n";
  fprintf fd "parameter STATE_BITS = 1;\n";
  fprintf fd "parameter STATE_NUM = 1;\n";
  fprintf fd "parameter STATE_NUM_LOG2 = 1;\n";
  fprintf fd "parameter STATE_RST = 0;\n";
  fprintf fd "parameter STATE_TABLE = 1'b0;\n";
  fprintf fd "\n";
  fprintf fd "parameter TRANS_NUM = 1;\n";
  fprintf fd "parameter TRANS_TABLE = 4'b0x0x;\n";
  fprintf fd "\n";
  fprintf fd "input CLK, ARST;\n";
  fprintf fd "input [CTRL_IN_WIDTH-1:0] CTRL_IN;\n";
  fprintf fd "output reg [CTRL_OUT_WIDTH-1:0] CTRL_OUT;\n";
  fprintf fd "\n";
  fprintf fd "wire pos_clk = CLK == CLK_POLARITY;\n";
  fprintf fd "wire pos_arst = ARST == ARST_POLARITY;\n";
  fprintf fd "\n";
  fprintf fd "reg [STATE_BITS-1:0] state;\n";
  fprintf fd "reg [STATE_BITS-1:0] state_tmp;\n";
  fprintf fd "reg [STATE_BITS-1:0] next_state;\n";
  fprintf fd "\n";
  fprintf fd "reg [STATE_BITS-1:0] tr_state_in;\n";
  fprintf fd "reg [STATE_BITS-1:0] tr_state_out;\n";
  fprintf fd "reg [CTRL_IN_WIDTH-1:0] tr_ctrl_in;\n";
  fprintf fd "reg [CTRL_OUT_WIDTH-1:0] tr_ctrl_out;\n";
  fprintf fd "\n";
  fprintf fd "integer i;\n";
  fprintf fd "\n";
  fprintf fd "task tr_fetch;\n";
  fprintf fd "	input [31:0] tr_num;\n";
  fprintf fd "	reg [31:0] tr_pos;\n";
  fprintf fd "	reg [STATE_NUM_LOG2-1:0] state_num;\n";
  fprintf fd "	begin\n";
  fprintf fd "		tr_pos = (2*STATE_NUM_LOG2+CTRL_IN_WIDTH+CTRL_OUT_WIDTH)*tr_num;\n";
  fprintf fd "		tr_ctrl_out = TRANS_TABLE >> tr_pos;\n";
  fprintf fd "		tr_pos = tr_pos + CTRL_OUT_WIDTH;\n";
  fprintf fd "		state_num = TRANS_TABLE >> tr_pos;\n";
  fprintf fd "		tr_state_out = STATE_TABLE >> (STATE_BITS*state_num);\n";
  fprintf fd "		tr_pos = tr_pos + STATE_NUM_LOG2;\n";
  fprintf fd "		tr_ctrl_in = TRANS_TABLE >> tr_pos;\n";
  fprintf fd "		tr_pos = tr_pos + CTRL_IN_WIDTH;\n";
  fprintf fd "		state_num = TRANS_TABLE >> tr_pos;\n";
  fprintf fd "		tr_state_in = STATE_TABLE >> (STATE_BITS*state_num);\n";
  fprintf fd "		tr_pos = tr_pos + STATE_NUM_LOG2;\n";
  fprintf fd "	end\n";
  fprintf fd "endtask\n";
  fprintf fd "\n";
  fprintf fd "always @(posedge pos_clk, posedge pos_arst) begin\n";
  fprintf fd "	if (pos_arst) begin\n";
  fprintf fd "		state_tmp = STATE_TABLE[STATE_BITS*(STATE_RST+1)-1:STATE_BITS*STATE_RST];\n";
  fprintf fd "		for (i = 0; i < STATE_BITS; i = i+1)\n";
  fprintf fd "			if (state_tmp[i] === 1'bz)\n";
  fprintf fd "				state_tmp[i] = 0;\n";
  fprintf fd "		state <= state_tmp;\n";
  fprintf fd "	end else begin\n";
  fprintf fd "		state_tmp = next_state;\n";
  fprintf fd "		for (i = 0; i < STATE_BITS; i = i+1)\n";
  fprintf fd "			if (state_tmp[i] === 1'bz)\n";
  fprintf fd "				state_tmp[i] = 0;\n";
  fprintf fd "		state <= state_tmp;\n";
  fprintf fd "	end\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "always @(state, CTRL_IN) begin\n";
  fprintf fd "	next_state <= STATE_TABLE[STATE_BITS*(STATE_RST+1)-1:STATE_BITS*STATE_RST];\n";
  fprintf fd "	CTRL_OUT <= 'bx;\n";
  fprintf fd "	// $display(\"---\");\n";
  fprintf fd "	// $display(\"Q: %%b %%b\", state, CTRL_IN);\n";
  fprintf fd "	for (i = 0; i < TRANS_NUM; i = i+1) begin\n";
  fprintf fd "		tr_fetch(i);\n";
  fprintf fd "		// $display(\"T: %%b %%b -> %%b %%b [%%d]\", tr_state_in, tr_ctrl_in, tr_state_out, tr_ctrl_out, i);\n";
  fprintf fd "		casez ({state, CTRL_IN})\n";
  fprintf fd "			{tr_state_in, tr_ctrl_in}: begin\n";
  fprintf fd "				// $display(\"-> %%b %%b <-   MATCH\", state, CTRL_IN);\n";
  fprintf fd "				{next_state, CTRL_OUT} <= {tr_state_out, tr_ctrl_out};\n";
  fprintf fd "			end\n";
  fprintf fd "		endcase\n";
  fprintf fd "	end\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "`ifndef SIMLIB_NOMEM\n";
  fprintf fd "\n";
  fprintf fd "module \\$memrd (CLK, EN, ADDR, DATA);\n";
  fprintf fd "\n";
  fprintf fd "parameter MEMID = \"\";\n";
  fprintf fd "parameter ABITS = 8;\n";
  fprintf fd "parameter WIDTH = 8;\n";
  fprintf fd "\n";
  fprintf fd "parameter CLK_ENABLE = 0;\n";
  fprintf fd "parameter CLK_POLARITY = 0;\n";
  fprintf fd "parameter TRANSPARENT = 0;\n";
  fprintf fd "\n";
  fprintf fd "input CLK, EN;\n";
  fprintf fd "input [ABITS-1:0] ADDR;\n";
  fprintf fd "output [WIDTH-1:0] DATA;\n";
  fprintf fd "\n";
  fprintf fd "initial begin\n";
  fprintf fd "	if (MEMID != \"\") begin\n";
  fprintf fd "		$display(\"ERROR: Found non-simulatable instance of $memrd!\");\n";
  fprintf fd "		$finish;\n";
  fprintf fd "	end\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "module \\$memrd_v2 (CLK, EN, ARST, SRST, ADDR, DATA);\n";
  fprintf fd "\n";
  fprintf fd "parameter MEMID = \"\";\n";
  fprintf fd "parameter ABITS = 8;\n";
  fprintf fd "parameter WIDTH = 8;\n";
  fprintf fd "\n";
  fprintf fd "parameter CLK_ENABLE = 0;\n";
  fprintf fd "parameter CLK_POLARITY = 0;\n";
  fprintf fd "parameter TRANSPARENCY_MASK = 0;\n";
  fprintf fd "parameter COLLISION_X_MASK = 0;\n";
  fprintf fd "parameter ARST_VALUE = 0;\n";
  fprintf fd "parameter SRST_VALUE = 0;\n";
  fprintf fd "parameter INIT_VALUE = 0;\n";
  fprintf fd "parameter CE_OVER_SRST = 0;\n";
  fprintf fd "\n";
  fprintf fd "input CLK, EN, ARST, SRST;\n";
  fprintf fd "input [ABITS-1:0] ADDR;\n";
  fprintf fd "output [WIDTH-1:0] DATA;\n";
  fprintf fd "\n";
  fprintf fd "initial begin\n";
  fprintf fd "	if (MEMID != \"\") begin\n";
  fprintf fd "		$display(\"ERROR: Found non-simulatable instance of $memrd_v2!\");\n";
  fprintf fd "		$finish;\n";
  fprintf fd "	end\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$memwr (CLK, EN, ADDR, DATA);\n";
  fprintf fd "\n";
  fprintf fd "parameter MEMID = \"\";\n";
  fprintf fd "parameter ABITS = 8;\n";
  fprintf fd "parameter WIDTH = 8;\n";
  fprintf fd "\n";
  fprintf fd "parameter CLK_ENABLE = 0;\n";
  fprintf fd "parameter CLK_POLARITY = 0;\n";
  fprintf fd "parameter PRIORITY = 0;\n";
  fprintf fd "\n";
  fprintf fd "input CLK;\n";
  fprintf fd "input [WIDTH-1:0] EN;\n";
  fprintf fd "input [ABITS-1:0] ADDR;\n";
  fprintf fd "input [WIDTH-1:0] DATA;\n";
  fprintf fd "\n";
  fprintf fd "initial begin\n";
  fprintf fd "	if (MEMID != \"\") begin\n";
  fprintf fd "		$display(\"ERROR: Found non-simulatable instance of $memwr!\");\n";
  fprintf fd "		$finish;\n";
  fprintf fd "	end\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "module \\$memwr_v2 (CLK, EN, ADDR, DATA);\n";
  fprintf fd "\n";
  fprintf fd "parameter MEMID = \"\";\n";
  fprintf fd "parameter ABITS = 8;\n";
  fprintf fd "parameter WIDTH = 8;\n";
  fprintf fd "\n";
  fprintf fd "parameter CLK_ENABLE = 0;\n";
  fprintf fd "parameter CLK_POLARITY = 0;\n";
  fprintf fd "parameter PORTID = 0;\n";
  fprintf fd "parameter PRIORITY_MASK = 0;\n";
  fprintf fd "\n";
  fprintf fd "input CLK;\n";
  fprintf fd "input [WIDTH-1:0] EN;\n";
  fprintf fd "input [ABITS-1:0] ADDR;\n";
  fprintf fd "input [WIDTH-1:0] DATA;\n";
  fprintf fd "\n";
  fprintf fd "initial begin\n";
  fprintf fd "	if (MEMID != \"\") begin\n";
  fprintf fd "		$display(\"ERROR: Found non-simulatable instance of $memwr_v2!\");\n";
  fprintf fd "		$finish;\n";
  fprintf fd "	end\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$meminit (ADDR, DATA);\n";
  fprintf fd "\n";
  fprintf fd "parameter MEMID = \"\";\n";
  fprintf fd "parameter ABITS = 8;\n";
  fprintf fd "parameter WIDTH = 8;\n";
  fprintf fd "parameter WORDS = 1;\n";
  fprintf fd "\n";
  fprintf fd "parameter PRIORITY = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [ABITS-1:0] ADDR;\n";
  fprintf fd "input [WORDS*WIDTH-1:0] DATA;\n";
  fprintf fd "\n";
  fprintf fd "initial begin\n";
  fprintf fd "	if (MEMID != \"\") begin\n";
  fprintf fd "		$display(\"ERROR: Found non-simulatable instance of $meminit!\");\n";
  fprintf fd "		$finish;\n";
  fprintf fd "	end\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$meminit_v2 (ADDR, DATA, EN);\n";
  fprintf fd "\n";
  fprintf fd "parameter MEMID = \"\";\n";
  fprintf fd "parameter ABITS = 8;\n";
  fprintf fd "parameter WIDTH = 8;\n";
  fprintf fd "parameter WORDS = 1;\n";
  fprintf fd "\n";
  fprintf fd "parameter PRIORITY = 0;\n";
  fprintf fd "\n";
  fprintf fd "input [ABITS-1:0] ADDR;\n";
  fprintf fd "input [WORDS*WIDTH-1:0] DATA;\n";
  fprintf fd "input [WIDTH-1:0] EN;\n";
  fprintf fd "\n";
  fprintf fd "initial begin\n";
  fprintf fd "	if (MEMID != \"\") begin\n";
  fprintf fd "		$display(\"ERROR: Found non-simulatable instance of $meminit_v2!\");\n";
  fprintf fd "		$finish;\n";
  fprintf fd "	end\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n";
  fprintf fd "module \\$mem (RD_CLK, RD_EN, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA);\n";
  fprintf fd "\n";
  fprintf fd "parameter MEMID = \"\";\n";
  fprintf fd "parameter signed SIZE = 4;\n";
  fprintf fd "parameter signed OFFSET = 0;\n";
  fprintf fd "parameter signed ABITS = 2;\n";
  fprintf fd "parameter signed WIDTH = 8;\n";
  fprintf fd "parameter signed INIT = 1'bx;\n";
  fprintf fd "\n";
  fprintf fd "parameter signed RD_PORTS = 1;\n";
  fprintf fd "parameter RD_CLK_ENABLE = 1'b1;\n";
  fprintf fd "parameter RD_CLK_POLARITY = 1'b1;\n";
  fprintf fd "parameter RD_TRANSPARENT = 1'b1;\n";
  fprintf fd "\n";
  fprintf fd "parameter signed WR_PORTS = 1;\n";
  fprintf fd "parameter WR_CLK_ENABLE = 1'b1;\n";
  fprintf fd "parameter WR_CLK_POLARITY = 1'b1;\n";
  fprintf fd "\n";
  fprintf fd "input [RD_PORTS-1:0] RD_CLK;\n";
  fprintf fd "input [RD_PORTS-1:0] RD_EN;\n";
  fprintf fd "input [RD_PORTS*ABITS-1:0] RD_ADDR;\n";
  fprintf fd "output reg [RD_PORTS*WIDTH-1:0] RD_DATA;\n";
  fprintf fd "\n";
  fprintf fd "input [WR_PORTS-1:0] WR_CLK;\n";
  fprintf fd "input [WR_PORTS*WIDTH-1:0] WR_EN;\n";
  fprintf fd "input [WR_PORTS*ABITS-1:0] WR_ADDR;\n";
  fprintf fd "input [WR_PORTS*WIDTH-1:0] WR_DATA;\n";
  fprintf fd "\n";
  fprintf fd "reg [WIDTH-1:0] memory [SIZE-1:0];\n";
  fprintf fd "\n";
  fprintf fd "integer i, j;\n";
  fprintf fd "reg [WR_PORTS-1:0] LAST_WR_CLK;\n";
  fprintf fd "reg [RD_PORTS-1:0] LAST_RD_CLK;\n";
  fprintf fd "\n";
  fprintf fd "function port_active;\n";
  fprintf fd "	input clk_enable;\n";
  fprintf fd "	input clk_polarity;\n";
  fprintf fd "	input last_clk;\n";
  fprintf fd "	input this_clk;\n";
  fprintf fd "	begin\n";
  fprintf fd "		casez ({clk_enable, clk_polarity, last_clk, this_clk})\n";
  fprintf fd "			4'b0???: port_active = 1;\n";
  fprintf fd "			4'b1101: port_active = 1;\n";
  fprintf fd "			4'b1010: port_active = 1;\n";
  fprintf fd "			default: port_active = 0;\n";
  fprintf fd "		endcase\n";
  fprintf fd "	end\n";
  fprintf fd "endfunction\n";
  fprintf fd "\n";
  fprintf fd "initial begin\n";
  fprintf fd "	for (i = 0; i < SIZE; i = i+1)\n";
  fprintf fd "		memory[i] = INIT >>> (i*WIDTH);\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "always @(RD_CLK, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA) begin\n";
  fprintf fd "`ifdef SIMLIB_MEMDELAY\n";
  fprintf fd "	#`SIMLIB_MEMDELAY;\n";
  fprintf fd "`endif\n";
  fprintf fd "	for (i = 0; i < RD_PORTS; i = i+1) begin\n";
  fprintf fd "		if (!RD_TRANSPARENT[i] && RD_CLK_ENABLE[i] && RD_EN[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin\n";
  fprintf fd "			// $display(\"Read from %%s: addr=%%b data=%%b\", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);\n";
  fprintf fd "			RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];\n";
  fprintf fd "		end\n";
  fprintf fd "	end\n";
  fprintf fd "\n";
  fprintf fd "	for (i = 0; i < WR_PORTS; i = i+1) begin\n";
  fprintf fd "		if (port_active(WR_CLK_ENABLE[i], WR_CLK_POLARITY[i], LAST_WR_CLK[i], WR_CLK[i]))\n";
  fprintf fd "			for (j = 0; j < WIDTH; j = j+1)\n";
  fprintf fd "				if (WR_EN[i*WIDTH+j]) begin\n";
  fprintf fd "					// $display(\"Write to %%s: addr=%%b data=%%b\", MEMID, WR_ADDR[i*ABITS +: ABITS], WR_DATA[i*WIDTH+j]);\n";
  fprintf fd "					memory[WR_ADDR[i*ABITS +: ABITS] - OFFSET][j] = WR_DATA[i*WIDTH+j];\n";
  fprintf fd "				end\n";
  fprintf fd "	end\n";
  fprintf fd "\n";
  fprintf fd "	for (i = 0; i < RD_PORTS; i = i+1) begin\n";
  fprintf fd "		if ((RD_TRANSPARENT[i] || !RD_CLK_ENABLE[i]) && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin\n";
  fprintf fd "			// $display(\"Transparent read from %%s: addr=%%b data=%%b\", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);\n";
  fprintf fd "			RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];\n";
  fprintf fd "		end\n";
  fprintf fd "	end\n";
  fprintf fd "\n";
  fprintf fd "	LAST_RD_CLK <= RD_CLK;\n";
  fprintf fd "	LAST_WR_CLK <= WR_CLK;\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "module \\$mem_v2 (RD_CLK, RD_EN, RD_ARST, RD_SRST, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA);\n";
  fprintf fd "\n";
  fprintf fd "parameter MEMID = \"\";\n";
  fprintf fd "parameter signed SIZE = 4;\n";
  fprintf fd "parameter signed OFFSET = 0;\n";
  fprintf fd "parameter signed ABITS = 2;\n";
  fprintf fd "parameter signed WIDTH = 8;\n";
  fprintf fd "parameter signed INIT = 1'bx;\n";
  fprintf fd "\n";
  fprintf fd "parameter signed RD_PORTS = 1;\n";
  fprintf fd "parameter RD_CLK_ENABLE = 1'b1;\n";
  fprintf fd "parameter RD_CLK_POLARITY = 1'b1;\n";
  fprintf fd "parameter RD_TRANSPARENCY_MASK = 1'b0;\n";
  fprintf fd "parameter RD_COLLISION_X_MASK = 1'b0;\n";
  fprintf fd "parameter RD_WIDE_CONTINUATION = 1'b0;\n";
  fprintf fd "parameter RD_CE_OVER_SRST = 1'b0;\n";
  fprintf fd "parameter RD_ARST_VALUE = 1'b0;\n";
  fprintf fd "parameter RD_SRST_VALUE = 1'b0;\n";
  fprintf fd "parameter RD_INIT_VALUE = 1'b0;\n";
  fprintf fd "\n";
  fprintf fd "parameter signed WR_PORTS = 1;\n";
  fprintf fd "parameter WR_CLK_ENABLE = 1'b1;\n";
  fprintf fd "parameter WR_CLK_POLARITY = 1'b1;\n";
  fprintf fd "parameter WR_PRIORITY_MASK = 1'b0;\n";
  fprintf fd "parameter WR_WIDE_CONTINUATION = 1'b0;\n";
  fprintf fd "\n";
  fprintf fd "input [RD_PORTS-1:0] RD_CLK;\n";
  fprintf fd "input [RD_PORTS-1:0] RD_EN;\n";
  fprintf fd "input [RD_PORTS-1:0] RD_ARST;\n";
  fprintf fd "input [RD_PORTS-1:0] RD_SRST;\n";
  fprintf fd "input [RD_PORTS*ABITS-1:0] RD_ADDR;\n";
  fprintf fd "output reg [RD_PORTS*WIDTH-1:0] RD_DATA;\n";
  fprintf fd "\n";
  fprintf fd "input [WR_PORTS-1:0] WR_CLK;\n";
  fprintf fd "input [WR_PORTS*WIDTH-1:0] WR_EN;\n";
  fprintf fd "input [WR_PORTS*ABITS-1:0] WR_ADDR;\n";
  fprintf fd "input [WR_PORTS*WIDTH-1:0] WR_DATA;\n";
  fprintf fd "\n";
  fprintf fd "reg [WIDTH-1:0] memory [SIZE-1:0];\n";
  fprintf fd "\n";
  fprintf fd "integer i, j, k;\n";
  fprintf fd "reg [WR_PORTS-1:0] LAST_WR_CLK;\n";
  fprintf fd "reg [RD_PORTS-1:0] LAST_RD_CLK;\n";
  fprintf fd "\n";
  fprintf fd "function port_active;\n";
  fprintf fd "	input clk_enable;\n";
  fprintf fd "	input clk_polarity;\n";
  fprintf fd "	input last_clk;\n";
  fprintf fd "	input this_clk;\n";
  fprintf fd "	begin\n";
  fprintf fd "		casez ({clk_enable, clk_polarity, last_clk, this_clk})\n";
  fprintf fd "			4'b0???: port_active = 1;\n";
  fprintf fd "			4'b1101: port_active = 1;\n";
  fprintf fd "			4'b1010: port_active = 1;\n";
  fprintf fd "			default: port_active = 0;\n";
  fprintf fd "		endcase\n";
  fprintf fd "	end\n";
  fprintf fd "endfunction\n";
  fprintf fd "\n";
  fprintf fd "initial begin\n";
  fprintf fd "	for (i = 0; i < SIZE; i = i+1)\n";
  fprintf fd "		memory[i] = INIT >>> (i*WIDTH);\n";
  fprintf fd "	RD_DATA = RD_INIT_VALUE;\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "always @(RD_CLK, RD_ARST, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA) begin\n";
  fprintf fd "`ifdef SIMLIB_MEMDELAY\n";
  fprintf fd "	#`SIMLIB_MEMDELAY;\n";
  fprintf fd "`endif\n";
  fprintf fd "	for (i = 0; i < RD_PORTS; i = i+1) begin\n";
  fprintf fd "		if (RD_CLK_ENABLE[i] && RD_EN[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin\n";
  fprintf fd "			// $display(\"Read from %%s: addr=%%b data=%%b\", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);\n";
  fprintf fd "			RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];\n";
  fprintf fd "\n";
  fprintf fd "			for (j = 0; j < WR_PORTS; j = j+1) begin\n";
  fprintf fd "				if (RD_TRANSPARENCY_MASK[i*WR_PORTS + j] && port_active(WR_CLK_ENABLE[j], WR_CLK_POLARITY[j], LAST_WR_CLK[j], WR_CLK[j]) && RD_ADDR[i*ABITS +: ABITS] == WR_ADDR[j*ABITS +: ABITS])\n";
  fprintf fd "					for (k = 0; k < WIDTH; k = k+1)\n";
  fprintf fd "						if (WR_EN[j*WIDTH+k])\n";
  fprintf fd "							RD_DATA[i*WIDTH+k] <= WR_DATA[j*WIDTH+k];\n";
  fprintf fd "				if (RD_COLLISION_X_MASK[i*WR_PORTS + j] && port_active(WR_CLK_ENABLE[j], WR_CLK_POLARITY[j], LAST_WR_CLK[j], WR_CLK[j]) && RD_ADDR[i*ABITS +: ABITS] == WR_ADDR[j*ABITS +: ABITS])\n";
  fprintf fd "					for (k = 0; k < WIDTH; k = k+1)\n";
  fprintf fd "						if (WR_EN[j*WIDTH+k])\n";
  fprintf fd "							RD_DATA[i*WIDTH+k] <= 1'bx;\n";
  fprintf fd "			end\n";
  fprintf fd "		end\n";
  fprintf fd "	end\n";
  fprintf fd "\n";
  fprintf fd "	for (i = 0; i < WR_PORTS; i = i+1) begin\n";
  fprintf fd "		if (port_active(WR_CLK_ENABLE[i], WR_CLK_POLARITY[i], LAST_WR_CLK[i], WR_CLK[i]))\n";
  fprintf fd "			for (j = 0; j < WIDTH; j = j+1)\n";
  fprintf fd "				if (WR_EN[i*WIDTH+j]) begin\n";
  fprintf fd "					// $display(\"Write to %%s: addr=%%b data=%%b\", MEMID, WR_ADDR[i*ABITS +: ABITS], WR_DATA[i*WIDTH+j]);\n";
  fprintf fd "					memory[WR_ADDR[i*ABITS +: ABITS] - OFFSET][j] = WR_DATA[i*WIDTH+j];\n";
  fprintf fd "				end\n";
  fprintf fd "	end\n";
  fprintf fd "\n";
  fprintf fd "	for (i = 0; i < RD_PORTS; i = i+1) begin\n";
  fprintf fd "		if (!RD_CLK_ENABLE[i]) begin\n";
  fprintf fd "			// $display(\"Combinatorial read from %%s: addr=%%b data=%%b\", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);\n";
  fprintf fd "			RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];\n";
  fprintf fd "		end\n";
  fprintf fd "	end\n";
  fprintf fd "\n";
  fprintf fd "	for (i = 0; i < RD_PORTS; i = i+1) begin\n";
  fprintf fd "		if (RD_SRST[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i]) && (RD_EN[i] || !RD_CE_OVER_SRST[i]))\n";
  fprintf fd "			RD_DATA[i*WIDTH +: WIDTH] <= RD_SRST_VALUE[i*WIDTH +: WIDTH];\n";
  fprintf fd "		if (RD_ARST[i])\n";
  fprintf fd "			RD_DATA[i*WIDTH +: WIDTH] <= RD_ARST_VALUE[i*WIDTH +: WIDTH];\n";
  fprintf fd "	end\n";
  fprintf fd "\n";
  fprintf fd "	LAST_RD_CLK <= RD_CLK;\n";
  fprintf fd "	LAST_WR_CLK <= WR_CLK;\n";
  fprintf fd "end\n";
  fprintf fd "\n";
  fprintf fd "endmodule\n";
  fprintf fd "\n";
  fprintf fd "`endif\n";
  fprintf fd "\n";
*)
  fprintf fd "// --------------------------------------------------------\n";
  fprintf fd "\n"
