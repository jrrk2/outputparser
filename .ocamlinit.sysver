
(*
open Output
open Template
open Output_parser
open Vxml

let _ = parse "V3ParseBison.output";;
let (t,g) = List.hd !tg';;
let mungelst = ref [];;
Hashtbl.iter (fun k x -> mungelst := (k,x) :: !mungelst) mungeh;;
let fd = open_out "mungelst.ml" in
List.iter ( fun (k,x) ->
	  Printf.fprintf fd "    %s, \"%s\";\n" k x
	  ) (List.sort compare !mungelst);
close_out fd
;;
*)

(*
#use "topfind";;
#require "msat";;
*)
#print_depth 100;;

#directory "/Users/jonathan/.opam/413/lib"
#directory "/Users/jonathan/.opam/413/lib/msat/backtrack"
#directory "/Users/jonathan/.opam/413/lib/msat/backend"
#directory "/Users/jonathan/.opam/413/lib/msat/sat"
#directory "/Users/jonathan/.opam/413/lib/msat"

open Source_text_rewrite_types
open Source_text_rewrite
open Source_text_main
open Source_text_lex
open Source_text
open Input_rewrite_types
open Dump_rtlil
open Matchmly
open Source_text_main.F
open String_lit
;;

let v = "timer.v";;
let v = "interface_test.sv";;
let v = "wrapper.sv";;
let v = "loop.v";;
let v = "picorv32_ref.v";;
let v = "process.v";;
let v = "preprocess.sv";;
let v = "blocking.v";;
let v = "prec.sv";;
let v = "casetest.sv";;
let v = "apb_uart.vsyn";;
let v = "insider.sv";;
let v = "ariane_preproc.sv";;
let v = "apb_uart.sv";;
let v = "examples/count.v";;
let v = "examples/count0.v";;
let v = "examples/add.v";;
let v = "examples/array.v";;
let v = "examples/array2.v";;
let v = "examples/concat1.v";;
let v = "examples/count.v";;
let v = "examples/count1.v";;
let v = "examples/count2.v";;
let v = "examples/count3.v";;
let v = "examples/count4.v";;
let v = "examples/count5.v";;
let v = "examples/count6.v";;
let v = "examples/count7.v";;
let v = "examples/range.v";;
let v = "../yosys/tests/simple/process.v";;
let v = "examples/shiftx.v";;
let v = "examples/array.v";;
let v = "examples/taskfunc1.v";;
let v = "examples/taskfunc4.v";;
let v = "../yosys/tests/simple/memory.v";;
let v = "../yosys/tests/simple/task_func.v";;
let v = "../yosys/tests/simple/operators.v";;
let v = "../yosys/tests/simple/sincos.v";;
let v = "../VlogHammer/rtl/expression_00000.v";;
let v = "../yosys/tests/simple/aes_kexp128.v";;
let v = "../yosys/tests/simple/arraycells.v";;
let v = "../yosys/tests/simple/attrib01_module.v";;
let v = "../yosys/tests/simple/attrib09_case.v";;
let v = "../yosys/tests/simple/carryadd.v";;
let v = "../yosys/tests/simple/arrays01.v";;
let v = "../yosys/tests/simple/case_expr_const.v";;
let v = "../yosys/tests/simple/case_large.v";;
let v = "../yosys/tests/simple/const_fold_func.v";;
let v = "../yosys/tests/simple/process.v";;
let v = "../yosys/tests/simple/implicit_ports.v";;
let v = "../yosys/tests/simple/forloops.v";;
let v = "../yosys/tests/simple/realexpr.v";;
let v = "../yosys/tests/simple/wandwor.v";;
let v = "../yosys/tests/simple/omsp_dbg_uart.v";;
let v = "../yosys/tests/simple/specify.v";;
let v = "../yosys/tests/simple/values.v";;
let v = "../yosys/tests/simple/rotate.v";;
let v = "examples/picorv32_ref.v";;
let v = "examples/count1.v";;
let v = "examples/count0.v";;
let v = "examples/count2.v";;
let v = "examples/count3.v";;
let v = "examples/count4.v";;
let v = "examples/count5.v";;
let v = "examples/arith.v";;
let v = "examples/add.v";;
let v = "examples/multest.v";;

(*
let x = rw (parse v);;
*)

(* *)
let (modlst,x,p,p') = rewrite_rtlil v;;
(* *)

let x crnt = sub' (List.assoc crnt !Matchmly.modules);;
let t id = Hashtbl.find !dbgtyp id;;
let u = snd (List.hd modlst);;
let m crnt = List.assoc crnt !(Matchmly.modules);;
let p u = output_string stdout (Input_dump.dump_ilst "\n" u);;

let (typhash, dhash, inst, edglst, body) = match !dbgproc with
    | Some (typhash, dhash, inst, edglst, body) -> (typhash, dhash, inst, edglst, body)
    | None -> print_endline "dbgproc is empty"; Hashtbl.create 1, Hashtbl.create 1, "", [], Seq("", [])

let e crnt = sub' (m crnt);;

let tlst = ref [];;
Hashtbl.iter (fun k x -> tlst := (k,x) :: !tlst) !dbgtyp;;
let tlst = !tlst;;

(*
let u' = List.filter (function DeclReg _ -> false| _ -> true) u;;

Let _ = Hashtbl.iter (fun k x -> let fd = open_out (k^".dump") in dump fd x; close_out fd) modules;;

let y = unroll {subst=Hashtbl.create 255; fn=descend} x;;

let z = Hashtbl.find modules "apb_uart";;
let Modul(entnam, parms, port_lst, body_lst) = z;;
let s, s' = List.partition (function Sentry _ -> false | DeclReg _ -> false | Asgnlst _ -> false | DeclIntf1 _ -> false | Hash _ -> false | _ -> true) body_lst;;
let h = List.filter (function Hash _ -> true | _ -> false) s';;

let a x = List.nth s x;;

let b = List.filter (function DeclReg _ -> false | Asgnlst _ -> true | Sentry _ -> false | _ -> false) body_lst;;

let rwmods = Hashtbl.create 255;;

let scanp = 
  List.iter (function
    | TUPLE7 (TUPLE3 (Module, EMPTY_TOKEN, IDENTIFIER nam), arg1, arg2, arg3, arg4, arg5, arg6) -> Hashtbl.add rwmods nam (arg1, arg2, arg3, arg4, arg5, arg6)
    | _ -> failwith "scanp")

let _ = match p' with
    | TUPLE2(TLIST lst, _) -> scanp lst
    | _ -> ();;

let declhash = Hashtbl.create 255;;
let conthash = Hashtbl.create 255;;
let othdecl = ref None
let othasgn = ref None

let (arg1, arg2, arg3, arg4, arg5, arg6) = Hashtbl.find rwmods "apb_uart";;
let TLIST lst = arg4;;
let lst',lst'' = List.partition (function TUPLE5 (Assign, _, _, _, _) -> true | _ -> false) lst;;
let lst''' = List.filter (function
  | TUPLE2 (Always, _) -> false
  | TUPLE4 (IDENTIFIER _, TUPLE4(HASH, _, _, _), _, _) -> false
  | TUPLE4 (IDENTIFIER _, EMPTY_TOKEN, TLIST (TUPLE5 _ :: _), _) -> false
  | _ -> true) lst'';;
let _ = List.iter (function
  | TUPLE3 (TUPLE3 (Reg, EMPTY_TOKEN, dimlst), TLIST [TUPLE3 (IDENTIFIER lhs, EMPTY_TOKEN, EMPTY_TOKEN)], SEMICOLON) as x -> Hashtbl.replace declhash lhs x
  | TUPLE3 (TUPLE3 (EMPTY_TOKEN, TYPE_HYPHEN_IDENTIFIER typ_id, EMPTY_TOKEN), TLIST [TUPLE3 (IDENTIFIER lhs, EMPTY_TOKEN, EMPTY_TOKEN)], SEMICOLON) as x -> Hashtbl.replace declhash lhs x
  | TUPLE4 (IDENTIFIER typ_id, EMPTY_TOKEN, TLIST [TUPLE2 (IDENTIFIER lhs, EMPTY_TOKEN)], SEMICOLON) as x -> Hashtbl.replace declhash lhs x
  | TUPLE6 (Typedef, TUPLE5 (Enum, typ_decl, LBRACE, TLIST id_lst, RBRACE), IDENTIFIER typ_id, EMPTY_TOKEN, EMPTY_TOKEN, SEMICOLON) as x -> Hashtbl.replace declhash typ_id x
  | TUPLE6 (Typedef, TUPLE5 (Enum, typ_decl, LBRACE, TLIST lst, RBRACE), TYPE_HYPHEN_IDENTIFIER typ_id, EMPTY_TOKEN, EMPTY_TOKEN, SEMICOLON) as x ->  Hashtbl.replace declhash typ_id x
  | TUPLE3 (TUPLE3 (Logic, EMPTY_TOKEN, EMPTY_TOKEN), TLIST lst, SEMICOLON) as x -> List.iter (function TUPLE3 (IDENTIFIER nam, EMPTY_TOKEN, EMPTY_TOKEN) -> Hashtbl.replace declhash nam x) lst
  | TUPLE3 (TUPLE3 (EMPTY_TOKEN, TYPE_HYPHEN_IDENTIFIER typ, EMPTY_TOKEN), TLIST lst, SEMICOLON) as x -> List.iter (function
      | TUPLE3 (IDENTIFIER nam, EMPTY_TOKEN, EMPTY_TOKEN) -> Hashtbl.replace declhash nam x
      | oth -> othdecl := Some oth; failwith "Decltyp" ) lst
  | oth -> othdecl := Some oth; failwith "Decl") lst''';;

let alst' = List.filter (function
  | TUPLE2 (Always, _) -> true
  | _ -> false) lst'';;

let caselst = ref [];;

let _ = List.iter (function
  | TUPLE2 (Always,
     TUPLE2
      (TUPLE4 (AT, LPAREN, TUPLE3 (_, Or, _), RPAREN),
       TUPLE8 (EMPTY_TOKEN, If, LPAREN, _, RPAREN, TUPLE4 (Begin, TLIST lst1, End, EMPTY_TOKEN), Else, TUPLE4 (Begin, TLIST lst, _, _)))) -> ()
  | TUPLE2 (Always,
      TUPLE2 (TUPLE4 (AT, LPAREN, _, RPAREN),
        TUPLE4 (Begin,
          TLIST
           [TLIST
             [TUPLE5
               (EMPTY_TOKEN,
                TUPLE4 (Case, LPAREN, _, RPAREN),
                EMPTY_TOKEN,
                TLIST lst1,
		Endcase)]], End, EMPTY_TOKEN))) -> caselst := lst1 :: !caselst
  | oth -> othasgn := Some oth; failwith "always") alst';;

let itms = ref [];;
let itms' = ref [];;
let _ = List.iter (collapse_case itms itms') (List.rev (List.hd !caselst));;

let _ = List.iter (function
  | TUPLE5 (Assign, EMPTY_TOKEN, EMPTY_TOKEN, TLIST [TUPLE3 (IDENTIFIER lhs, EQUALS, expr)], SEMICOLON) -> Hashtbl.replace conthash lhs expr
  | TUPLE5 (Assign, EMPTY_TOKEN, EMPTY_TOKEN, TLIST [TUPLE3 (TUPLE6 (IDENTIFIER lhs, LBRACK, hi, COLON, lo, RBRACK), EQUALS, expr)], SEMICOLON) -> Hashtbl.replace conthash lhs expr
  | TUPLE5 (Assign, EMPTY_TOKEN, EMPTY_TOKEN, TLIST [TUPLE3 (TUPLE4 (IDENTIFIER lhs, LBRACK, ix, RBRACK), EQUALS, expr)], SEMICOLON) -> Hashtbl.replace conthash lhs expr
  | oth -> othasgn := Some oth; failwith "Assign") lst';;

let v' = List.filter (function
 | (Source_text_rewrite_types.Add _, _, _) -> false
 | ((Sub _ |Id _|Number _ | Intgr _ | Slice _ | Sel _ | Equals _ | GtEq _ | Expression (Equals _) | Expression (Or (Equals _ , Equals _))), _, _) -> false
 | (And2 _, _, _) -> true
 | _ ->false) !vlst;;

*)
